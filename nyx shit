--[[
getgenv Example:

getgenv("Test", true)
getgenv().Test = true


-----------------------------------------------------
-[hooking Global Functions:

a = function() -- Setting a Global Function named: a
    return false
end

print(a()) -- Output: false

hookfunction(a, function()
    return true
end)

print(a()) -- Output: true

or

newtbl = {hello = "world"}

print(newtbl.hello) -- Output: world

hookfunction({"newtbl", "hello"}, "game") -- Hooking newtbl.hello

print(newtbl.hello) -- Output: game

------------------------
hooking Local Functions:

local b = function() -- Setting a Local Function named: b
    return false
end

print(b()) -- Output: false

hookfunction(b, function()
    return true
end)

print(b()) -- Output: false -- Could not hook the Function/Table.

or

local newtbl = {hello = "world"}

print(newtbl.hello) -- Output: world

hookfunction({"newtbl", "hello"}, "game") -- Hooking newtbl.hello

print(newtbl.hello) -- Output: world -- Could not hook the Function/Table.
-]

]]
--[[
error = function(...) -- Fake Error
	local a = {...}
	local b = function(ss)
		local aa = "nyx"
		local bb = debug.info(ss, "l")
		return "Script '"..aa.."', Line "..tostring(bb)
	end
	warn("nyx"..":"..debug.info(3, "l")..":","nyx"..":"..debug.info(2, "l")..":", table.concat(a, " "))
	warn("Stack Begin")
	warn(b(1)) -- Tracing back info '1'
	warn(b(2)) -- Tracing back info '2'
	warn(b(3)) -- Tracing back info '3'
	warn("Stack End")
	coroutine.yield() -- Stop Thread
end
]]

newcclosure = function(a)
    return coroutine.wrap(function(...)
        while true do
            coroutine.yield(a(...))
        end
    end)
end
clonefunction = newcclosure

isexecutorclosure = function(func)
    return (not getfenv()[debug.info(func, "n")] or debug.info(func, "s") ~= "[C]") and true or (false)
end
checkclosure = isexecutorclosure
isourclosure = isexecutorclosure

getgenv = function(a, b) -- Bad getgenv, it is detected in games that have a check if getfenv is edited. It might get detected or not.
    return a and b and rawset(getfenv(), a, b) or rawget(getfenv(), a) or setmetatable({}, {__index = getfenv(),__newindex = function(self, index, value)getfenv()[index] = value end})
end

--[[
Cheat:
getgenv().Hello = "Hello There"

Anti-Cheat:

spawn(function()
    local o = {}
    for i,v in pairs(getfenv()) do
        o[v] = true
    end
    while true do
        for i, v in pairs(getfenv()) do
            if not o[i] then
                o[i] = true
                print(i, v) -- Output: Hello "Hello There"
            end
        end
        wait()
    end
end)
]]

getgenv().NyxData = getgenv().NyxData or {ReadOnly = {}, Luau_setmetatable = setmetatable}

iscclosure = function(a) -- Returns true if 'a' is C Closure
    return not pcall(function(b,c)
        setfenv(a, getfenv(a))
        return b,c
    end)
end

islclosure = function(a) -- Returns true if 'a' is Lua Closure
    return pcall(function(b,c)
        setfenv(a, getfenv(a))
        return b,c
    end)
end

hookfunction = function(a,b) -- Bad Hooking Implementation in Luau, can only hook global Functions and not local Functions. Upvalues and localn would be better for local hooking.
    if not rawget(getfenv(), a) and a ~= nil and type(a) == "function" then -- Checks if a is not nil but is in getfenv and is a function.
        local c = debug.info(a, "n")
        a = c ~= "" and c or a -- if 'a' is a function, it gets its name. This will only work with Global functions and not Local. If this doesnt work, it gets the old 'a'
    end
    if type(a) == "function" or type(a) == "string" then --Simple Detection Bypass, but it is crap.
        for i,v in pairs(getfenv()) do
            if v == a then -- Checks if 'v' is 'a', so this is just checking if our function is inside getfenv.
                a = i -- setting 'a' to be 'i' so we can hook it later.
            end
        end
        if not getfenv()[a] then -- Warns if 'a' is nil inside getfenv.
            error(" Could not hook the Function.") -- Output: Could not hook the Function.
        end
        local c = rawset(getfenv(), a, b) -- Sets a to be b (Hooking)
        return rawget(getfenv(), a) or a -- rawget is Semi Detected, simply getting 'a' would be more of a security Problem, so it checks if rawget func is nil.
    elseif type(a) == "table" then -- This is not table hooking, this is function hooking. a[1] = a table, a[2] = the function inside the table.
        local tbl = getfenv()
        local hooking = ""
        if not getfenv()[a[1]] then  -- Warns if a[1] is not in getfenv is nil.
            error("Could not hook the Function in the Table.") -- Output: Could not hook the Function in the Table.
        end
        getfenv()[a[1]] = table.clone(getfenv()[a[1]]) -- Making table Writable.
        for i=1,#a do
            tbl = tbl[a[i]]
            hooking = hooking ~= "" and hooking.."."..tostring(a[i]) or tostring(a[i]) -- This is not Important, was just testing. It writes the Function you are trying to hook, an example: {"table", "freeze"} == table.freeze
            if i == #a then
                getfenv()[a[i-1]][a[i]] = b -- (Hooking)
                return getfenv()[a[i-1]][a[i]] -- Only works up to 2 Variables in a table. This needs to be fixed asap.
            end
        end
    end
end
replaceclosure = hookfunction


local Luau_setmetatable = setmetatable
local Saved_Metatable = {}
hookfunction(setmetatable, function(a, b) -- Hooking setmetatable
    local c, d = pcall(function()
        local c = Luau_setmetatable(a, b) --getgenv().NyxData.
    end)
    Saved_Metatable[a] = b
    if not c then
        error(d)
    end
    return a
end)

getrawmetatable = function(a)
    return Saved_Metatable[a]
end

setrawmetatable = function(a, b)
    local mtbl = getrawmetatable(a)
    table.foreach(b, function(aa, bb)
        mtbl[aa] = bb
    end)
    return a
end

isreadonly = function(tbl)
    return getgenv().NyxData.ReadOnly[tbl]
end

setreadonly = function(tbl, readOnly)
    getgenv().NyxData.ReadOnly[tbl] = readOnly
    tbl = table.clone(tbl)

    return setmetatable(tbl, {
        __index = function(tbl, key)
            return tbl[key]
        end,
        __newindex = function(tbl, key, value)
            if readOnly == true then
                error("attempt to modify a readonly table")
            else
                rawset(tbl, key, value)
            end
        end
    })
end

hookfunction({"table", "freeze"}, function(tbl) -- Hooking table.freeze
    return setreadonly(tbl, true) -- Removing the contents of this will still make it work due to never setting the table to be frozen, as long as table.freeze function exists.
end)

hookmetamethod = function(ins, mm, func)
    local rmtb = getrawmetatable(ins)
    local old = rmtb[mm]
    setreadonly(rmtb, false)
    rmtb[mm] = func
    setreadonly(rmtb, true)
    return old
end

getexecutorname = function()
    return "nyx"
end

getexecutorversion = function()
    return "4.0" -- Update your Version here, dont forget this ;)
end

identifyexecutor = function()
    return getexecutorname(), getexecutorversion()
end

gethui = function()
    return game:GetService("CoreGui")
end

getinstances = function()
    return game:GetDescendants()
end

getscripts = function()
    local a = {}
    for i, v in pairs(getinstances()) do
        if v:IsA("LocalScript") or v:IsA("ModuleScript") then
            table.insert(a, v)
        end
    end
    return a
end

getloadedmodules = function() -- This gets ALL Modules, not the ones that are in loaded in the caller's Thread.
    local b = {}
    for i, v in pairs(getscripts()) do
        if v:IsA("ModuleScript") then
            table.insert(b, v)
        end
    end
    return b
end

getrenv = function()
    return getfenv()._G
end

getthreadidentity_v2 = function() -- Crappy way to get Identity. (Message Logging)
    game:GetService("LogService").MessageOut:Connect(function(message)
        if message:find("nyx: ") then 
            getgenv().Identity = tonumber(message:sub(5))
        end
    end)
    printidentity("nyx: ")
    if not getgenv().Identity then 
        game:GetService("RunService").Heartbeat:Wait() 
    end
    return getgenv().Identity
end

getthreadidentity = function() -- Still Crappy way to get Identity, but at least it doesn't Output anything.
    local pm0 = pcall(function()
        return game.Name
    end)
    local pm3 = pcall(function()
        return game.DataCost
    end)
    local pm4 = pcall(function()
        game.Players.LocalPlayer.Name = game.Players.LocalPlayer.Name
    end)
    local pm5 = pcall(function()
        game:GetService("ScriptContext"):AddCoreScriptLocal("__", workspace)
    end)
    local pm6 = pcall(function()
        return game:GetService("CSGDictionaryService"):GetChildren()
    end)
    local pm7 = pcall(function()
        return game:GetService("StudioData")
    end)
    
    return pm7 and 7 or pm6 and 6 or pm5 and 5 or pm4 and 4 or pm3 and 3 or 2
end

invalidated = {}
replaced = {}
cache = {}

-- Bad Cache Implementation in Luau. This needs to be reworked.
cache.invalidate = function(instance)
    local old_archivable = instance.Archivable
    local clone
    instance.Archivable = true
    clone = instance:Clone()
    instance.Archivable = old_archivable
    local old_parent = instance.Parent
    table.insert(invalidated, instance)
    instance.Parent = nil
    clone.Parent = old_parent
end

cache.iscached = function(instance)
    return table.find(invalidated, instance) == nil
end

cache.replace = function(instance, value)
    replaced[tostring(instance)] = value
end

local oldIns = Instance

-- Hooking Instance.new
hookfunction({"Instance", "new"}, function(instance, parent)
    if parent == game then
        parent = game.Workspace.Parent
    end
    replaced[tostring(instance)] = instance
    return oldIns.new(instance, parent)
end)

lz4compress = function(input)
    local output = ""
    local pos = 1
    local len = #input
    while pos <= len do
        local max_match_len = 0
        local max_match_pos = pos
        for i = pos - 1, 1, -1 do
            local match_len = 0
            while i + match_len <= len and input:sub(pos + match_len, pos + match_len) == input:sub(i + match_len, i + match_len) do
                match_len = match_len + 1
            end
            if match_len > max_match_len then
                max_match_len = match_len
                max_match_pos = i
            end
        end
        local match_pos, match_len = max_match_pos, max_match_len
        if match_len > 4 then
            output = output .. "*" .. string.char(math.floor(match_pos / 256)) .. string.char(match_pos % 256) .. string.char((match_len - 4) % 256)
            pos = pos + match_len
        else
            output = output .. input:sub(pos, pos)
            pos = pos + 1
        end
    end
    return output
end

lz4decompress = function(input)
    local output = ""
    local pos = 1
    local len = #input
    while pos <= len do
        local byte = input:sub(pos, pos)
        if byte == "*" then
            local match_pos = input:byte(pos + 1) * 256 + input:byte(pos + 2)
            local match_len = input:byte(pos + 3) + 4
            output = output .. output:sub(#output - match_pos + 1, #output - match_pos + match_len)
            pos = pos + 4
        else
            output = output .. byte
            pos = pos + 1
        end
    end
    return output
end

debug = table.clone(debug)

-- Implementation of debug.getinfo in Luau. Other debug stuff seem hard, so I will leave them.
debug.getinfo = function(f)
    if f == 0 then
        f = 1
    elseif type(f) == "number" then
        f = f + 1
    end
    
    local s, n, a, v, l, f = debug.info(f, "snalf")
    
    return {
        source = (s == "[C]" and "@[C]") or "[C]",
        short_src = s,
        func = f,
        what = (s == "[C]" and "C") or "Lua",
        currentline = l,
        name = n,
        nups = -1,
        numparams = a,
        is_vararg = (v and 1) or 0
    }
end

isrbxactive_ = false
local UserInputService = game:GetService("UserInputService")

UserInputService.WindowFocusReleased:Connect(function()
    isrbxactive_ = false
end)

UserInputService.WindowFocused:Connect(function()
    isrbxactive_ = true
end)

isrbxactive = function()
    return isrbxactive_
end

isgameactive = isrbxactive

checkcaller = function()
    return true
end

--crypt = {base64 = {}}

function base64encode(data)
    local b = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    return ((data:gsub('.', function(x)
        local r, b = '', x:byte()
        for i = 8, 1, -1 do
            r = r .. (b % 2^i - b % 2^(i - 1) > 0 and '1' or '0')
        end
        return r
    end):gsub('%d%d%d?%d?%d?%d?', function(x)
        if (#x < 6) then return '' end
        local c = 0
        for i = 1, 6 do
            c = c + (x:sub(i, i) == '1' and 2^(6 - i) or 0)
        end
        return b:sub(c + 1, c + 1)
    end) .. ({ '', '==', '=' })[#data % 3 + 1])
end

function base64decode(data)
    local b = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    data = string.gsub(data, '[^' .. b .. '=]', '')
    return (data:gsub('.', function(x)
        if (x == '=') then return '' end
        local r, f = '', (b:find(x) - 1)
        for i = 6, 1, -1 do
            r = r .. (f % 2^i - f % 2^(i - 1) > 0 and '1' or '0')
        end
        return r
    end):gsub('%d%d%d?%d?%d?%d?%d?%d?', function(x)
        if (#x ~= 8) then return '' end
        local c = 0
        for i = 1, 8 do
            c = c + (x:sub(i, i) == '1' and 2^(8 - i) or 0)
        end
        return string.char(c)
    end))
end


function getrunningscripts()
    local returnable = {}
    for _, v in game:GetDescendants() do
        if v:IsA("LocalScript") or v:IsA("ModuleScript") then
            if not v:IsA("ModuleScript") and v.Enabled then
                returnable[#returnable + 1] = v
            end
            if v:IsA("ModuleScript") then
                returnable[#returnable + 1] = v
            end
        end
    end
    return returnable
end

getcallingscript = function()
    local s = debug.info(1, 's')
    for i, v in next, game:GetDescendants() do
        if v:GetFullName() == s then
            return v
        end
    end
    return nil
end

local nyx_context = 3

function getthreadidentity()
    return nyx_context
end

function getidentity()
    return nyx_context
end

function getthreadcontext()
    return nyx_context
end

function setthreadidentity(identity)
    return nyx_context
end

function setidentity(identity)
    return nyx_context
end

function setthreadcontext(identity)
    return nyx_context
end

function fireclickdetector(part)
    local cd = part:FindFirstChild("ClickDetector") or part
    local oldParent = cd.Parent
    local p = Instance.new("Part")
    p.Transparency = 1
    p.Size = Vector3.new(30, 30, 30)
    p.Anchored = true
    p.CanCollide = false
    p.Parent = workspace
    cd.Parent = p
    cd.MaxActivationDistance = math.huge
    local conn
    conn = game["Run Service"].Heartbeat:Connect(function()
        p.CFrame = workspace.Camera.CFrame * CFrame.new(0, 0, -20) * CFrame.new(workspace.Camera.CFrame.LookVector.X, workspace.Camera.CFrame.LookVector.Y, workspace.Camera.CFrame.LookVector.Z)
        game:GetService("VirtualUser"):ClickButton1(Vector2.new(20, 20), workspace:FindFirstChildOfClass("Camera").CFrame)
    end)
    cd.MouseClick:Once(function()
        conn:Disconnect()
        cd.Parent = oldParent
        p:Destroy()
    end)
end

function request(options)
    assert(type(options) == "table", "invalid argument #1 to 'request' (table expected, got " .. type(options) .. ") ", 2)
    local Event = Instance.new("BindableEvent")
    local RequestInternal = game:GetService("HttpService").RequestInternal
    local Request = RequestInternal(game:GetService("HttpService"), options)
    local Start = Request.Start
    local Response
    Start(Request, function(state, response)
        Response = response
        Event:Fire()
    end)
    Event.Event:Wait()
    return Response
end

function HttpGet(url)
    assert(type(url) == "string", "invalid argument #1 to 'httpget' (string expected, got " .. type(url) .. ") ", 2)
    local response = request({ Url = url; Method = "GET"; }).Body
    task.wait()
    return response
end

function http_request(url)
    assert(type(url) == "string", "invalid argument #1 to 'httpget' (string expected, got " .. type(url) .. ") ", 2)
    local response = request({ Url = url; Method = "GET"; }).Body
    task.wait()
    return response
end


local RunService = game:GetService("RunService")
local frameTime = 1 / 60
local capped = false

function setfpscap(fps)
    if fps == 0 then
        capped = false
        RunService:Set3dRenderingEnabled(true)
    else
        frameTime = 1 / fps
        capped = true
        RunService:Set3dRenderingEnabled(false)
    end
end

function getfpscap()
    return 60
end

local instances_reg = setmetatable({ [game] = true }, { __mode = "ks" })

local function filterAllInstances(filter)
    local result = {}
    local idx = 1

    for instance in instances_reg do
        if not (filter(instance)) then
            continue
        end
        result[idx] = instance
        idx += 1
    end
    return result
end

getnilinstances = function()
    return filterAllInstances(function(instance)
        return instance.Parent == nil
    end)
end

function queueonteleport()
end

function getscripthash(a)
    assert(typeof(a) == "Instance" and a:IsA("LuaSourceContainer"), "argument #1 is not a 'LuaSourceContainer'", 0)
    return a:GetHash()
end

function isscriptable(a, b)
    assert(typeof(a) == "Instance", "argument #1 is not an 'Instance'", 0)
    assert(typeof(b) == "string", "argument #2 is not a 'string'", 0)
    
    local old
    local c, d = pcall(function()
        old = a[b]
        a[b] = "bombom"
        return a[b] == "bombom"
    end)
    
    if c then
        a[b] = old
    end
    
    return c
end

local Cache_FTI = setmetatable({}, { __mode = "s" })

firetouchinterest = function(WithPart, TouchPart, State)
    local function BelongsToCharacter(part)
        local m = part.Parent
        while m do
            if m:FindFirstChildOfClass("Humanoid") then
                return true
            end
            m = m.Parent
        end
        return false
    end

    if BelongsToCharacter(TouchPart) then
        TouchPart, WithPart = WithPart, TouchPart
    end

    State = if State == 0 or State == true then true elseif State == 1 or State == false then false else nil

    if State == nil then
        firetouchinterest(WithPart, TouchPart, 0)
        firetouchinterest(WithPart, TouchPart, 1)
    else
        local Info = Cache_FTI[TouchPart]
        if Info then
            if Info.WithPart == WithPart and Info.State == State then
                return
            end
            while not Info.Thread do
                task.wait()
            end
            local Thread = Info.Thread
            Cache_FTI[TouchPart] = nil
            while coroutine.status(Thread) ~= "dead" do
                task.wait()
            end
        end

        local OriginalCF = TouchPart.CFrame
        Info = { WithPart = WithPart, State = State }
        Cache_FTI[TouchPart] = Info -- preemptively
        local CanCollide = TouchPart.CanCollide
        TouchPart.CanCollide = false
        local FiredOnce -- * I know we can use Event.Connected instead but we would have to inverse it (or at the very least index it) each loop which isn't ideal for optimisation
        local Event = TouchPart[if State then "Touched" else "TouchEnded"]:Once(function()
            FiredOnce = true
        end)
        Info.Thread = task.spawn(function()
            if State then
                TouchPart.CFrame = WithPart.CFrame
                task.wait() --* let it process
            end
            if not FiredOnce then
                local TouchEmulator = if State
                    then function()
                        TouchPart.CFrame = OriginalCF
                        task.wait()
                        TouchPart.CFrame = WithPart.CFrame
                    end
                    else function()
                        TouchPart.CFrame = WithPart.CFrame
                        task.wait()
                        TouchPart.CFrame = OriginalCF
                    end
                local StartTime = os.clock()
                repeat
                    TouchEmulator()
                until FiredOnce or 0.5 < os.clock() - StartTime --! Hopefully within this delay we manage to touch, this is basically a solution to many edge-cases outlined at the top of this func's definition (especially cases where the parts refuse to fire event for few reasons)
            end
            task.spawn(function()
                if Event.Connected then
                    Event:Disconnect()
                end
            end)
            if State then
                TouchPart.CFrame = OriginalCF
            end
            if CanCollide then
                TouchPart.CanCollide = CanCollide
            end
            Cache_FTI[TouchPart] = nil -- * Clean up
        end)
    end
end

function setclipboard(text)
    -- assert(type(text) == "string", "invalid argument #1 to 'setclipboard' (string expected, got " .. type(text) .. ") ", 2)
    local response = request({
        Url = "http://localhost:6969/setclipboard/" .. text;
        Method = "GET";
    }).Body
    task.wait()
    return response
end

function getclipboard()
    local response = request({
        Url = "http://localhost:6969/getclipboard";
        Method = "GET";
    }).Body
    task.wait()
    return response
end

function system(text)
    return HttpGet("http://localhost:6969/system/" .. text)
end

http = {}
http.request = function(url)
    return http_request(url)
end

-- Setting up the camera and container
local camera = workspace.CurrentCamera

local drawing_container = Instance.new("ScreenGui")
drawing_container.Name = "Drawing"
drawing_container.IgnoreGuiInset = true
drawing_container.DisplayOrder = 0x7fffffff

-- Creating a template for drawing wedges
local wedge_template = Instance.new("ImageLabel")
wedge_template.BackgroundTransparency = 1
wedge_template.AnchorPoint = Vector2.one / 2
wedge_template.BorderSizePixel = 0
wedge_template.Image = "rbxassetid://0"
wedge_template.ImageColor3 = Color3.new()
wedge_template.ZIndex = 0

-- Variables
local vect2_half = Vector2.one / 2
local drawing_idx = 0

local drawing_obj_reg = {}

-- Base drawing object
local base_drawing_obj = setmetatable({
    Visible = true,
    ZIndex = 0,
    Transparency = 1,
    Color = Color3.new(),
    Remove = function(self)
        setmetatable(self, nil)
        
        local obj_idx = table.find(drawing_obj_reg, self)
        if obj_idx then
            table.remove(drawing_obj_reg, obj_idx)
        end
    end,
}, {
    __add = function(t1, t2)
        local result = table.clone(t1)
        
        for index, value in t2 do
            result[index] = value
        end
        return result
    end,
})

-- List of drawing fonts
local drawing_fonts_list = {
    [0] = Font.fromEnum(Enum.Font.BuilderSans),
    Font.fromEnum(Enum.Font.Arial),
    Font.fromEnum(Enum.Font.Nunito),
    Font.fromEnum(Enum.Font.RobotoMono),
}

-- Triangle assets
local triangle_assets = {
    left = "rbxassetid://319692171",
    right = "rbxassetid://319692151",
}

-- Functions
local function get_font_from_idx(font_idx)
    return drawing_fonts_list[font_idx]
end

local function convert_dtransparency(transparency)
    return math.clamp(1 - transparency, 0, 1)
end

-- from egomoose: https://github.com/EgoMoose/Articles/blob/master/2d%20triangles/2d%20triangles.md
local function new_2d_triangle(parent)
    local wedges = {
        w1 = wedge_template:Clone(),
        w2 = wedge_template:Clone(),
    }
    local is_destroyed = false
    
    wedges.w1.Parent = parent
    wedges.w2.Parent = parent
    
    local function construct_triangle(point_a, point_b, point_c)
        if is_destroyed then
            return
        end
        
        if not (wedges.w1.Visible and wedges.w2.Visible) then
            return
        end
        
        local ab, ac, bc = point_b - point_a, point_c - point_a, point_c - point_b
        local abd, acd, bcd = ab:Dot(ab), ac:Dot(ac), bc:Dot(bc)
        
        if abd > acd and abd > bcd then
            point_c, point_a = point_a, point_c
        elseif acd > bcd and acd > abd then
            point_a, point_b = point_b, point_a
        end
        
        ab, ac, bc = (point_b - point_a), (point_c - point_a), (point_c - point_b)
        
        local unit = bc.Unit
        local height = unit:Cross(ab)
        local flip = (height >= 0)
        local theta = math.deg(math.atan2(unit.y, unit.x)) + (if flip then 0 else 180)
        
        local m1 = (point_a + point_b) / 2
        local m2 = (point_a + point_c) / 2
        
        wedges.w1.Image = (if flip then triangle_assets.right else triangle_assets.left)
        wedges.w1.AnchorPoint = vect2_half
        wedges.w1.Size = UDim2.fromOffset(math.abs(unit:Dot(ab)), height)
        wedges.w1.Position = UDim2.fromOffset(m1.x, m1.y)
        wedges.w1.Rotation = theta
        
        wedges.w2.Image = (if flip then triangle_assets.left else triangle_assets.right)
        wedges.w2.AnchorPoint = vect2_half
        wedges.w2.Size = UDim2.fromOffset(math.abs(unit:Dot(ac)), height)
        wedges.w2.Position = UDim2.fromOffset(m2.x, m2.y)
        wedges.w2.Rotation = theta
    end
    
    local function destroy_triangle()
        is_destroyed = true
        
        for _, obj in wedges do
            obj:Destroy()
        end
        table.clear(wedges)
    end
    
    return construct_triangle, destroy_triangle, wedges
end

-- Main
local drawing_lib = {}
drawing_lib.Fonts = {
    ["UI"] = 0,
    ["System"] = 1,
    ["Plex"] = 2,
    ["Monospace"] = 3,
}
do
    local function new_drawing_obj(drawing_type)
        drawing_idx = drawing_idx + 1
        local drawing_obj = {}
    
        if drawing_type == "Line" then
            local drawing_info = {
                From = Vector2.zero,
                To = Vector2.zero,
                Thickness = 1,
            } + base_drawing_obj
    
            local lineFrame = Instance.new("Frame")
            lineFrame.Name = tostring(drawing_idx)
            lineFrame.AnchorPoint = Vector2.one * 0.5
            lineFrame.BorderSizePixel = 0
    
            lineFrame.BackgroundColor3 = drawing_info.Color
            lineFrame.Visible = drawing_info.Visible
            lineFrame.ZIndex = drawing_info.ZIndex
            lineFrame.BackgroundTransparency = convert_dtransparency(drawing_info.Transparency)
    
            lineFrame.Size = UDim2.new()
            lineFrame.Parent = drawing_container
    
            return setmetatable(drawing_obj, {
                __newindex = function(_, index, value)
                    if type(drawing_info[index]) == "nil" then
                        return
                    end
    
                    if index == "From" then
                        local direction = drawing_info.To - value
                        local center = (drawing_info.To + value) / 2
                        local distance = direction.Magnitude
                        local theta = math.deg(math.atan2(direction.Y, direction.X))
    
                        lineFrame.Position = UDim2.fromOffset(center.X, center.Y)
                        lineFrame.Rotation = theta
                        lineFrame.Size = UDim2.fromOffset(distance, drawing_info.Thickness)
                    elseif index == "To" then
                        local direction = value - drawing_info.From
                        local center = (value + drawing_info.From) / 2
                        local distance = direction.Magnitude
                        local theta = math.deg(math.atan2(direction.Y, direction.X))
    
                        lineFrame.Position = UDim2.fromOffset(center.X, center.Y)
                        lineFrame.Rotation = theta
                        lineFrame.Size = UDim2.fromOffset(distance, drawing_info.Thickness)
                    elseif index == "Thickness" then
                        local distance = (drawing_info.To - drawing_info.From).Magnitude
                        lineFrame.Size = UDim2.fromOffset(distance, value)
                    elseif index == "Visible" then
                        lineFrame.Visible = value
                    elseif index == "ZIndex" then
                        lineFrame.ZIndex = value
                    elseif index == "Transparency" then
                        lineFrame.BackgroundTransparency = convert_dtransparency(value)
                    elseif index == "Color" then
                        lineFrame.BackgroundColor3 = value
                    end
                    drawing_info[index] = value
                end,
                __index = function(self, index)
                    if index == "Remove" or index == "Destroy" then
                        return function()
                            lineFrame:Destroy()
                            drawing_info.Remove(self)
                            return drawing_info:Remove()
                        end
                    end
                    return drawing_info[index]
                end,
            })
        elseif drawing_type == "Text" then
            local drawing_info = {
                Text = "",
                Font = Enum.Font.SourceSans,
                Size = 14,
                Position = Vector2.zero,
                Center = false,
                Outline = false,
                OutlineColor = Color3.new(0, 0, 0),
                Color = Color3.new(1, 1, 1),
                Visible = true,
                ZIndex = 1,
                Transparency = 0
            }
            drawing_info = setmetatable(drawing_info, {__index = base_drawing_obj})
    
            local textLabel = Instance.new("TextLabel")
            local uiStroke = Instance.new("UIStroke")
            textLabel.Name = tostring(drawing_idx)
            textLabel.AnchorPoint = Vector2.one * 0.5
            textLabel.BorderSizePixel = 0
            textLabel.BackgroundTransparency = 1
            textLabel.Visible = drawing_info.Visible
            textLabel.TextColor3 = drawing_info.Color
            textLabel.TextTransparency = convert_dtransparency(drawing_info.Transparency)
            textLabel.ZIndex = drawing_info.ZIndex
            textLabel.FontFace = get_font_from_idx(drawing_info.Font)
            textLabel.TextSize = drawing_info.Size
    
            textLabel:GetPropertyChangedSignal("TextBounds"):Connect(function()
                local textBounds = textLabel.TextBounds
                local offset = textBounds / 2
    
                textLabel.Size = UDim2.fromOffset(textBounds.X, textBounds.Y)
                textLabel.Position = UDim2.fromOffset(
                    drawing_info.Position.X + (drawing_info.Center and 0 or offset.X),
                    drawing_info.Position.Y + offset.Y
                )
            end)
    
            uiStroke.Thickness = 1
            uiStroke.Enabled = drawing_info.Outline
            uiStroke.Color = drawing_info.OutlineColor
            uiStroke.Parent = textLabel
            textLabel.Parent = drawing_container
    
            return setmetatable(drawing_obj, {
                __newindex = function(_, index, value)
                    if type(drawing_info[index]) == "nil" then
                        return
                    end
    
                    if index == "Text" then
                        textLabel.Text = value
                    elseif index == "Font" then
                        value = math.clamp(value, 0, 3)
                        textLabel.FontFace = get_font_from_idx(value)
                    elseif index == "Size" then
                        textLabel.TextSize = value
                    elseif index == "Position" then
                        local offset = textLabel.TextBounds / 2
                        textLabel.Position = UDim2.fromOffset(
                            value.X + (drawing_info.Center and 0 or offset.X),
                            value.Y + offset.Y
                        )
                    elseif index == "Center" then
                        local position = drawing_info.Center and drawing_container.AbsoluteSize / 2 or drawing_info.Position
                        textLabel.Position = UDim2.fromOffset(position.X, position.Y)
                    elseif index == "Outline" then
                        uiStroke.Enabled = value
                    elseif index == "OutlineColor" then
                        uiStroke.Color = value
                    elseif index == "Visible" then
                        textLabel.Visible = value
                    elseif index == "ZIndex" then
                        textLabel.ZIndex = value
                    elseif index == "Transparency" then
                        local transparency = convert_dtransparency(value)
                        textLabel.TextTransparency = transparency
                        uiStroke.Transparency = transparency
                    elseif index == "Color" then
                        textLabel.TextColor3 = value
                    end
    
                    drawing_info[index] = value
                end,
                __index = function(self, index)
                    if index == "Remove" or index == "Destroy" then
                        return function()
                            textLabel:Destroy()
                            drawing_info.Remove(self)
                            return drawing_info:Remove()
                        end
                    elseif index == "TextBounds" then
                        return textLabel.TextBounds
                    end
                    return drawing_info[index]
                end,
            })
        elseif drawing_type == "Circle" then
            local drawing_info = {
                Radius = 150,
                Position = Vector2.zero,
                Thickness = 0.7,
                Filled = false,
            }
            for k, v in pairs(base_drawing_obj) do
                drawing_info[k] = v
            end
    
            local circleFrame = Instance.new("Frame")
            local uiCorner = Instance.new("UICorner")
            local uiStroke = Instance.new("UIStroke")
    
            circleFrame.Name = drawing_idx
            circleFrame.AnchorPoint = Vector2.one * 0.5
            circleFrame.BorderSizePixel = 0
            circleFrame.BackgroundTransparency = drawing_info.Filled and convert_dtransparency(drawing_info.Transparency) or 1
            circleFrame.BackgroundColor3 = drawing_info.Color
            circleFrame.Visible = drawing_info.Visible
            circleFrame.ZIndex = drawing_info.ZIndex
    
            uiCorner.CornerRadius = UDim.new(1, 0)
            circleFrame.Size = UDim2.fromOffset(drawing_info.Radius, drawing_info.Radius)
    
            uiStroke.Thickness = drawing_info.Thickness
            uiStroke.Enabled = not drawing_info.Filled
            uiStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
    
            circleFrame.Parent = drawing_container
            uiCorner.Parent = circleFrame
            uiStroke.Parent = circleFrame
    
            return setmetatable(drawing_obj, {
                __newindex = function(_, index, value)
                    if drawing_info[index] == nil then return end
    
                    if index == "Radius" then
                        local radius = value * 2
                        circleFrame.Size = UDim2.fromOffset(radius, radius)
                    elseif index == "Position" then
                        circleFrame.Position = UDim2.fromOffset(value.X, value.Y)
                    elseif index == "Thickness" then
                        value = math.clamp(value, 0.6, 0x7fffffff)
                        uiStroke.Thickness = value
                    elseif index == "Filled" then
                        circleFrame.BackgroundTransparency = value and convert_dtransparency(drawing_info.Transparency) or 1
                        uiStroke.Enabled = not value
                    elseif index == "Visible" then
                        circleFrame.Visible = value
                    elseif index == "ZIndex" then
                        circleFrame.ZIndex = value
                    elseif index == "Transparency" then
                        local transparency = convert_dtransparency(value)
                        circleFrame.BackgroundTransparency = drawing_info.Filled and transparency or 1
                        uiStroke.Transparency = transparency
                    elseif index == "Color" then
                        circleFrame.BackgroundColor3 = value
                        uiStroke.Color = value
                    end
                    drawing_info[index] = value
                end,
                __index = function(self, index)
                    if index == "Remove" or index == "Destroy" then
                        return function()
                            circleFrame:Destroy()
                            drawing_info.Remove(self)
                            return drawing_info:Remove()
                        end
                    end
                    return drawing_info[index]
                end,
            })
        elseif drawing_type == "Square" then
            local drawing_info = {
                Size = Vector2.zero,
                Position = Vector2.zero,
                Thickness = 0.7,
                Filled = false,
            }
            for k, v in pairs(base_drawing_obj) do
                drawing_info[k] = v
            end
    
            local squareFrame = Instance.new("Frame")
            local uiStroke = Instance.new("UIStroke")
    
            squareFrame.Name = drawing_idx
            squareFrame.BorderSizePixel = 0
            squareFrame.BackgroundTransparency = drawing_info.Filled and convert_dtransparency(drawing_info.Transparency) or 1
            squareFrame.ZIndex = drawing_info.ZIndex
            squareFrame.BackgroundColor3 = drawing_info.Color
            squareFrame.Visible = drawing_info.Visible
    
            uiStroke.Thickness = drawing_info.Thickness
            uiStroke.Enabled = not drawing_info.Filled
            uiStroke.LineJoinMode = Enum.LineJoinMode.Miter
    
            squareFrame.Parent = drawing_container
            uiStroke.Parent = squareFrame
    
            return setmetatable(drawing_obj, {
                __newindex = function(_, index, value)
                    if drawing_info[index] == nil then return end
    
                    if index == "Size" then
                        squareFrame.Size = UDim2.fromOffset(value.X, value.Y)
                    elseif index == "Position" then
                        squareFrame.Position = UDim2.fromOffset(value.X, value.Y)
                    elseif index == "Thickness" then
                        value = math.clamp(value, 0.6, 0x7fffffff)
                        uiStroke.Thickness = value
                    elseif index == "Filled" then
                        squareFrame.BackgroundTransparency = value and convert_dtransparency(drawing_info.Transparency) or 1
                        uiStroke.Enabled = not value
                    elseif index == "Visible" then
                        squareFrame.Visible = value
                    elseif index == "ZIndex" then
                        squareFrame.ZIndex = value
                    elseif index == "Transparency" then
                        local transparency = convert_dtransparency(value)
                        squareFrame.BackgroundTransparency = drawing_info.Filled and transparency or 1
                        uiStroke.Transparency = transparency
                    elseif index == "Color" then
                        uiStroke.Color = value
                        squareFrame.BackgroundColor3 = value
                    end
                    drawing_info[index] = value
                end,
                __index = function(self, index)
                    if index == "Remove" or index == "Destroy" then
                        return function()
                            squareFrame:Destroy()
                            drawing_info.Remove(self)
                            return drawing_info:Remove()
                        end
                    end
                    return drawing_info[index]
                end,
            })
        elseif drawing_type == "Image" then
            local drawing_info = {
                Data = "",
                DataURL = "rbxassetid://0",
                Size = Vector2.zero,
                Position = Vector2.zero,
                Visible = true,
                ZIndex = 1,
                Transparency = 0,
                Color = Color3.new(1, 1, 1),
            }
        
            setmetatable(drawing_info, { __index = base_drawing_obj })
        
            local imageFrame = Instance.new("ImageLabel")
            imageFrame.Name = drawing_idx
            imageFrame.BorderSizePixel = 0
            imageFrame.ScaleType = Enum.ScaleType.Stretch
            imageFrame.BackgroundTransparency = 1
        
            imageFrame.Visible = drawing_info.Visible
            imageFrame.ZIndex = drawing_info.ZIndex
            imageFrame.ImageTransparency = convert_dtransparency(drawing_info.Transparency)
            imageFrame.ImageColor3 = drawing_info.Color
        
            imageFrame.Parent = drawing_container
        
            return setmetatable({}, {
                __newindex = function(_, index, value)
                    if drawing_info[index] == nil then
                        return
                    end
        
                    if index == "DataURL" then
                        imageFrame.Image = value
                    elseif index == "Size" then
                        imageFrame.Size = UDim2.fromOffset(value.X, value.Y)
                    elseif index == "Position" then
                        imageFrame.Position = UDim2.fromOffset(value.X, value.Y)
                    elseif index == "Visible" then
                        imageFrame.Visible = value
                    elseif index == "ZIndex" then
                        imageFrame.ZIndex = value
                    elseif index == "Transparency" then
                        imageFrame.ImageTransparency = convert_dtransparency(value)
                    elseif index == "Color" then
                        imageFrame.ImageColor3 = value
                    end
        
                    drawing_info[index] = value
                end,
                __index = function(self, index)
                    if index == "Remove" or index == "Destroy" then
                        return function()
                            imageFrame:Destroy()
                            drawing_info.Remove(self)
                            return drawing_info:Remove()
                        end
                    end
                    return drawing_info[index]
                end,
            })
        elseif drawing_type == "Triangle" then
            local drawing_info = (
            {
                PointA = Vector2.zero,
                PointB = Vector2.zero,
                PointC = Vector2.zero,
                Thickness = 1,
                Filled = false,
            } + base_drawing_obj
        )

        local line_points = {}
        line_points.A = drawing_lib.new("Line")
        line_points.B = drawing_lib.new("Line")
        line_points.C = drawing_lib.new("Line")

        local construct_tri1, remove_tri1, wedges1 = new_2d_triangle(drawing_container)

        construct_tri1(drawing_info.PointA, drawing_info.PointB, drawing_info.PointC)
        wedges1.w1.Visible = drawing_info.Filled
        wedges1.w2.Visible = drawing_info.Filled

        return setmetatable(drawing_obj, {
            __newindex = function(_, index, value)
                if type(drawing_info[index]) == "nil" then
                    return
                end

                if index == "PointA" then
                    line_points.A.From = value
                    line_points.B.To = value
                    construct_tri1(value, drawing_info.PointB, drawing_info.PointC)
                elseif index == "PointB" then
                    line_points.B.From = value
                    line_points.C.To = value
                    construct_tri1(drawing_info.PointA, value, drawing_info.PointC)
                elseif index == "PointC" then
                    line_points.C.From = value
                    line_points.A.To = value
                    construct_tri1(drawing_info.PointA, drawing_info.PointB, value)
                elseif index == "Thickness" or index == "Visible" or index == "Color" or index == "Transparency" or index == "ZIndex" then
                    for _, line_obj in line_points do
                        line_obj[index] = value
                    end

                    if index == "Visible" then
                        wedges1.w1.Visible = (drawing_info.Filled and value)
                        wedges1.w2.Visible = (drawing_info.Filled and value)
                    elseif index == "ZIndex" then
                        wedges1.w1.ZIndex = value
                        wedges1.w2.ZIndex = value
                    elseif index == "Color" then
                        wedges1.w1.ImageColor3 = value
                        wedges1.w2.ImageColor3 = value
                    elseif index == "Transparency" then
                        wedges1.w1.ImageTransparency = convert_dtransparency(value)
                        wedges1.w2.ImageTransparency = convert_dtransparency(value)
                    end
                elseif index == "Filled" then
                    wedges1.w1.Visible = (drawing_info.Visible and value)
                    wedges1.w2.Visible = (drawing_info.Visible and value)
                end
                drawing_info[index] = value
            end,
            __index = function(self, index)
                if index == "Remove" or index == "Destroy" then
                    return function()
                        for _, line_obj in line_points do
                            line_obj:Remove()
                        end

                        remove_tri1()
                        drawing_info.Remove(self)
                        return drawing_info:Remove()
                    end
                end
                return drawing_info[index]
            end,
        })
    return error(`Drawing object "{drawing_type}" doesn't exist`)
end

function drawing_lib.new(...)
    local drawing_obj = new_drawing_obj(...)
    table.insert(drawing_obj_reg, drawing_obj)
    return drawing_obj
end

-- Misc drawing functions
local function clearDrawCache()
    for _, drawing_obj in pairs(drawing_obj_reg) do
        if not drawing_obj then
            goto continue
        end
        drawing_obj:Remove()
        ::continue::
    end
    table.clear(drawing_obj_reg)
end

local function isRenderObject(object)
    local objPos = table.find(drawing_obj_reg, object)
    return (objPos and type(drawing_obj_reg[objPos]) == "table") or false
end

local function getRenderProperty(object, property)
    local objPos = table.find(drawing_obj_reg, object)
    if not objPos then
        error("arg #1 not a valid render object")
    end

    return object[property]
end

local function setRenderProperty(object, property, value)
    local objPos = table.find(drawing_obj_reg, object)
    if not objPos then
        error("arg #1 not a valid render object")
    end

    if object[property] == nil then
        error(string.format("%s is not a valid render property", property))
    end

    object[property] = value
end

drawing_container.Parent = gethui()

Drawing = drawing_lib
cleardrawcache = clearDrawCache
isrenderobj = isRenderObject
getrenderproperty = getRenderProperty
setrenderproperty = setRenderProperty
